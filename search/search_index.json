{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"fastapi-docx","text":"<p> Add HTTPException responses to a FastAPI OpenAPI spec </p> <p> </p> <p>Documentation: https://saran33.github.io/fastapi-docx</p> <p>Source Code: https://github.com/Saran33/fastapi-docx</p> <p>FastAPI-docx extends the FastAPI OpenAPI spec to include all possible <code>HTTPException</code> or custom Exception response schemas that may be raised within path operations.</p> <p>The key features are:</p> <ul> <li>Document Exception Responses: Automatically find all possible respones within path operations, whether they originate from a <code>HTTPException</code> raised by the endpoint function directly, in a nested function, class method, or callable class instance, or by the fastAPI dependency-injection system.</li> <li>Include Custom Exceptions: Optionally find and document any custom Exception types if using custom Exception handlers in your FastAPI application.</li> <li>Generate Exception schemas: A default <code>HTTPExceptionSchema</code> will be added to the OpenAPI specification. The default can be modified to use any other Pydantic model. An additional schema for app-specific custom Exceptions can also be included.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#install-fastapi-docx","title":"Install fastapi-docx","text":"<pre><code>$ pip install fastapi-docx\n</code></pre>"},{"location":"custom-exceptions/","title":"Custom Exception Responses","text":""},{"location":"custom-exceptions/#find-application-specific-custom-exceptions","title":"Find application-specific custom exceptions","text":"<ul> <li>If implementing custom exception handlers, responses for your custom <code>Exception</code> types can also be documented. They can be included by passing a <code>customError</code> argument to the <code>custom_openapi</code> function.</li> <li>The <code>customError</code> needs to inherit from the Python <code>Exception</code> class. Each <code>customError</code> and subclass of <code>customError</code> should be instantiable without required arguments. i.e. if you are parameterising your custom exceptions, they should have defaults in their class constructor. If you use required positional arguments in your <code>customError</code> constructors, <code>fastapi-docx</code> will throw an error when attempting to evaluate your custom Exception from source code.</li> <li>If using custom exception handlers, you can pass your <code>customError</code> Base class, along with a Pydantic <code>customErrSchema</code> to the <code>custom_openapi</code> function when creating your OpenAPI spec:</li> </ul> <pre><code>from typing import Any\n\nfrom fastapi import Request\nfrom fastapi.utils import is_body_allowed_for_status_code\nfrom pydantic import BaseModel\nfrom starlette.responses import JSONResponse, Response\n\nfrom fastapi_docx.openapi import custom_openapi\n\n\nclass AppExecptionSchema(BaseModel):\n    exception: str | None = None\n    detail: str | None = None\n    context: dict[str, Any] | None = None\n\n\nclass AppExceptionCase(Exception):\n    def __init__(\n        self,\n        status_code: int,\n        detail: str,\n        context: dict[str, Any] | None = None,\n        headers: dict[str, Any] | None = None,\n    ):\n        self.case = self.__class__.__name__\n        self.status_code = status_code\n        self.headers = headers\n        self.detail = detail\n        self.context = context or \"\"\n\n\nasync def app_exception_handler(\n    request: Request, exc: AppExceptionCase\n) -&gt; JSONResponse:\n    if not is_body_allowed_for_status_code(exc.status_code):\n        return Response(status_code=exc.status_code, headers=exc.headers)\n    return JSONResponse(\n        status_code=exc.status_code,\n        headers=exc.headers,\n        content={\n            \"exception\": exc.case,\n            \"detail\": exc.detail,\n            \"context\": exc.context,\n        },\n    )\n\n\nclass AppExc:\n    class CreateFailed(AppExceptionCase):\n        def __init__(self, context: dict[str, Any] | None = None):\n            self.context = context or {}\n            status_code = 500\n            obj = self.context.get(\"obj\", \"object\")\n            detail = f\"{obj} creation failed\"\n            super().__init__(status_code, detail)\n\n    class ConnectionClosed(AppExceptionCase):\n        def __init__(self) -&gt; None:\n            status_code = 444\n            detail = \"Conection closed without response\"\n            super().__init__(status_code, detail)\n\n    class Unauthorized(AppExceptionCase):\n        def __init__(self, context: dict[str, Any] | None = None):\n            status_code = 401\n            detail = \"permission required\"\n            super().__init__(status_code, detail, context)\n\n\nclass RetryWith(AppExceptionCase):\n    def __init__(self, context: dict[str, Any] | None = None):\n        status_code = 449\n        detail = \"Retry the request\"\n        super().__init__(status_code, detail, context)\n\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef get_user(user_in):\n    if not user_in:\n        raise AppExc.CreateFailed({\"obj\": \"User\"})\n    elif user_in == \"John\":\n        raise RetryWith(context=\"abc\")\n    elif user_in == \"Saran\":\n        raise AppExc.ConnectionClosed()\n    elif user_in == \"Sam\":\n        raise AppExc.Unauthorized({\"obj\": \"User\", \"name\": \"Sam\"})\n    return user_in\n\n\n@app.exception_handler(AppExceptionCase)\nasync def custom_app_exception_handler(request, e):\n    return await app_exception_handler(request, e)\n\n\napp.openapi = custom_openapi(\n    app,\n    customError=AppExceptionCase,\n    customErrSchema=AppExecptionSchema,\n)\n</code></pre> <ul> <li>Visiting http://localhost:8080/docs (or whatever host and port your app is running on), should display the below documented responses:</li> </ul> <p>Note</p> <p>For adding different schemas to the default <code>HTTPExcSchema</code> for <code>HTTPException</code> responses, see Response Schemas.</p>"},{"location":"find-exception-responses/dependency-or-service-classes/","title":"Dependency or Service Classes","text":""},{"location":"find-exception-responses/dependency-or-service-classes/#find-exceptions-raised-in-class-methods-or-callable-class-instances","title":"Find exceptions raised in class methods or callable class instances","text":"<ul> <li>If your application is using classes for dependency-injection, or other classes for handling CRUD operations or business logic, you can specify these classes for inclusion in the OpenAPI spec.</li> <li>If any method owned by an instance of these dependency/service classes is called within a route (either directly or indirectly), every <code>HTTPException</code> raised within that method will be detected and added to the <code>OpenAPI</code> spec.</li> <li>Every <code>HTTPException</code> that might be raised within an instance method, <code>classmethod</code>, or <code>staticmethod</code> of a dependency class or a service class will be detected.</li> <li>The <code>dependencyClasses</code> and <code>serviceClasses</code> arguments passed to the <code>custom_openapi</code> function can either be a tuple of classes or a singleton base class from which all other service/dependency classes are derived.</li> <li>Any <code>HTTPException</code> raised within a callable Dependency instance will also be detected.</li> </ul>"},{"location":"find-exception-responses/dependency-or-service-classes/#dependency-classes","title":"Dependency Classes","text":"<ul> <li>A \"dependency class\" is defined here as any class that has a method called by the FastAPI dependency injection system (passed to the FastAPI <code>Depends</code> class, either in a path operation function or in any callable nested within a path operation).</li> <li>A common pattern would be to use a Base dependency class from which all other dependency classes inherit. The base class can then be passed to the <code>custom_openapi</code> function. The below example illustrates how to include every <code>HTTPException</code> raised within any class inheriting from a base <code>AppDeps</code> dependency class:</li> </ul> <p><pre><code>from fastapi import Depends, FastAPI, HTTPException, status\n\n\nclass AppDeps:\n    pass\n\n\nuser = {\"name\": \"Person\", \"id\": 2}\n\n\nclass UserDeps(AppDeps):\n    def __init__(self, user_id: int | None = None):\n        self.user_id = user_id\n\n    @staticmethod\n    def require_auth():\n        if not user:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN, detail=\"Unauthorized\"\n            )\n        return user\n\n    def instance_method(self, id):\n        if not id == user[\"id\"]:\n            raise HTTPException(status_code=407, detail=\"Some error\")\n        return user\n\n\napp = FastAPI()\n\n\n@app.get(\"/me\")\ndef get_user(*, user_in, current_user=Depends(UserDeps.get_current_user)):\n    return current_user\n\n\nuser_dep = UserDeps(3)\n\n\n@app.delete(\"/me\")\ndef delete_user(\n    *,\n    user_id: int,\n    some_dep: dict = Depends(user_dep.instance_method),\n):\n    return user_id\n\n\napp.openapi = custom_openapi(app, dependencyClasses=(AppDeps,))\n</code></pre> - In the above (contrived) example, any <code>HTTPException</code> rasied by a <code>UserDeps</code> method will be added to the API docs. The <code>dependencyClasses</code> parameter of the <code>custom_openapi</code> function accepts a tuple of classes as an argument. These classes will be searched for exception responses. In this case, we are passing only the base class from which <code>UserDeps</code> inherits, but any number of classes can be specified.</p>"},{"location":"find-exception-responses/dependency-or-service-classes/#service-classes","title":"Service Classes","text":"<ul> <li>A common pattern in FastAPI apps is to decouple business logic from endpoint functions by using some orchestration layer or \"service\". The term \"service\" is somewhat ambiguous. It could also incorporate some CRUD (Create Read Update Delete) / DAL (Data Access Layer) operations involving an ORM such as SQLAlchemy. For our intents and purposes, in the context of <code>fastapi-docx</code>, it doesn't matter how you structure your app. A <code>service</code> here can refer to any class that has a method called within a route, which might raise an exception response that you want to document.</li> <li>Similarly to dependency classes, \"service\" classes can be passed to the <code>custom_openapi</code> function via the <code>serviceClasses</code> paramater: <pre><code>from typing import Any\nfrom fastapi import Depends, FastAPI, HTTPException, status\n\n\nclass AppService:\n    pass\n\n\nclass UserService(AppService):\n    @staticmethod\n    def get_user(user_id: int) -&gt; dict[str, Any]:\n        user = {\"name\": \"Saran\", \"id\": user_id}\n        if not user_id:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST, detail=\"Bad request\"\n            )\n        return user\n\n    def create_user(self, user: dict[str, Any]) -&gt; dict[str, Any]:\n        if not user:\n            raise HTTPException(status_code=444, detail=\"Conection closed\")\n        return {\"name\": \"Saran\", \"id\": 2}\n\n    def do_something(self, user: dict[str, Any]) -&gt; dict[str, Any]:\n        if not user:\n            raise HTTPException(status_code=400, detail=\"Bad request\")\n        return {\"name\": \"Saran\", \"id\": 2}\n\n    @classmethod\n    def get_authenticated(cls, user_id: int) -&gt; dict[str, Any]:\n        return {\"name\": \"Saran\", \"id\": user_id}\n\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef get_user(user_in):\n    return UserService.get_user(user_in)\n\n\n@app.post(\"/\")\ndef create_user(user_in):\n    user = UserService().create_user(user_in)\n    user_serv = UserService()\n    result = user_serv.do_something(user)\n    if not result:\n        raise HTTPException(\n            status_code=420,\n            detail=\"Too many requests\"\n        )\n    return result\n\n\napp.openapi = custom_openapi(app, serviceClasses=(AppService,))\n</code></pre></li> </ul>"},{"location":"find-exception-responses/overview/","title":"Overview","text":""},{"location":"find-exception-responses/overview/#quick-start","title":"Quick Start","text":"<ul> <li> <p>In the below basic app, all of the possible <code>HTTPException</code> responses will be added to the openAPI spec. <pre><code>from fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi_docx import custom_openapi\n\napp = FastAPI()\n\n\ndef raise_exc():\n    raise HTTPException(status_code=400, detail=\"Some exception\")\n\n\ndef get_user():\n    raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Unauthorized\")\n\n\n@app.get(\"/\")\ndef home(item: int, user: str = Depends(get_user)):\n    if item == 1:\n        raise HTTPException(status_code=404, detail=\"Not found\")\n    raise_exc()\n\n\napp.openapi = custom_openapi(app)\n</code></pre></p> </li> <li> <p>Visiting http://localhost:8080/docs (or whatever host and port your app is running on), should display the below documented responses:</p> </li> </ul> <p></p>"},{"location":"response-schemas/","title":"Response Schemas","text":""},{"location":"response-schemas/#generate-schemas-for-the-openapi-specification","title":"Generate schemas for the OpenAPI specification","text":"<ul> <li>A default <code>HTTPExceptionSchema</code> will be added to the <code>OpenAPI</code> spec for every <code>HTTPException</code>. It defaults to one field: <code>detail: Optional[str]</code>. <pre><code>\"HTTPExceptionSchema\": {\n                \"title\": \"HTTPExceptionSchema\",\n                \"type\": \"object\",\n                \"properties\": {\"detail\": {\"title\": \"Detail\", \"type\": \"string\"}},\n            }\n</code></pre></li> <li>The default schema can be modified by passing a <code>HTTPExcSchema</code> Pydantic model to the <code>custom_openapi</code> function:</li> </ul> <p><pre><code>from typing import Any\nfrom pydantic import BaseModel\nfrom fastapi_docx.openapi import custom_openapi\n\n\nclass CustomExcSchema(BaseModel):\n    exception: str | None = None\n    detail: str | None = None\n    context: dict[str, Any] | None = None\n\n\napp.openapi = custom_openapi(app, HTTPExcSchema=CustomExcSchema)\n</code></pre> - Similarly, a <code>customErrSchema</code> can be passed to define the response structure for any <code>customError</code> class defined in your application.</p>"}]}